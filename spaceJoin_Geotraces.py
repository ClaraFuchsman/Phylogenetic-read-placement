#! /usr/bin/pythonimport sysimport osimport reimport os.pathimport shutilfrom optparse import OptionParserusage= """Takes an alignment file from PaPaRa -- identifies paired end reads and merges these reads for placement with EPAusage: %prog [-p FILE] [-r INT] [-o FILE] [-l INT] """parser = OptionParser(usage=usage, version="%prog 0.1")parser.add_option("-p", "--PaPaRa file", dest="alnFile",                  help="Specify the output file from PaPaRa that has the reference aln and metagenome reads aln combined",                  metavar="FILE")parser.add_option("-r", "--number of reference sequences in integer format", dest="refInt",                  help="Specify the number of reference sequences in the alignment",                  metavar="INT")parser.add_option("-o", "--output alingment filename", dest="outputFile",                  help="Specify the your desire output file name",                  metavar="FILE")parser.add_option("-l", "--minimum length of sequence", dest="minLen",				  help="Specify the minimum number of residues that must be in each read for placement",				  metavar="INT")(options, args) = parser.parse_args()#Makes sure all mandatory options appearmandatories = ["alnFile", "refInt", "minLen"]for m in mandatories:	if not options.__dict__[m]:		print "A mandatory option is missing!\n See the HELP menu - 'spaceJoin.py -h'" 		parser.print_help()		exit(-1)#Sets the default outputfile name	if options.outputFile == None:	outputName = options.alnFile	outputFileName = outputName + "joinedReadsForPlacement_OUT.txt"elif options.outputFile != None:	outputName = options.outputFile	outputFileName = outputName + "_joinedReadsForPlacement.txt"#Set variables based on collected inputpaparaAlnFileName = os.path.abspath(options.alnFile)referenceSeqCount = options.refIntrefCount = int(referenceSeqCount)minimumLength = options.minLenminLength = int(minimumLength)outputFile = open(outputFileName, "w")logFileName = "spaceJoin_LOGfile" + outputFileNamelogFile = open(logFileName, "w")alnFileOpen = open(paparaAlnFileName, "rU")alnFileFirstLine = alnFileOpen.readline()splitFirstLine = alnFileFirstLine.split(" ")numSeqsInFile = splitFirstLine[0]numPositionsInAln = splitFirstLine[1]###To test is a stringreprents and int valuedef RepresentsInt(string):	try:		int(string)		return True	except ValueError:		return False###Generate list to output laterouputLines = [] ###Create dictionary of reads for merging laterreads = {}preJoinedReads = {}###Read and open the rest of the aln filereferenceSequences = []alnFileRead = alnFileOpen.readlines()index = 1for line in alnFileRead:	#Removes the reference sequences	if index <= refCount:		referenceSequences.append(line)		outputFile.write(line)		index += 1			else:		numSpaces = line.count(" ")		line = line.replace("\n","")		lineSplit = line.split(" ")		readID = lineSplit[0]		readSequence = lineSplit[numSpaces]				readIDsplit=readID.split(".")		readPair = readIDsplit[2]		print readPair		readKey = readIDsplit[0]+"."+readIDsplit[1]				value = []#To handle the new combined reads in the blastdb which are pre-combined and lack an _1 or _2		if RepresentsInt(readPair) is False:			#print "Is String"			value = [numSpaces, readID, readSequence, "PreJoined"]		else:			#print "Is Int"			readPair = int(readPair)					if readPair == 1:				value = [numSpaces, readID, readSequence, 0, 0]				#print value			elif readPair == 2:				value = [numSpaces, 0, 0, readID, readSequence]			else:				print "Error #1"				print "\t\t" + readID		test = readKey in reads		if test is False:			### Add data			reads[readKey] = value		elif test is True:			### Pull old data & update			if readPair == 1:				oldValue = reads[readKey]				read2ID = oldValue[3]				read2Seq = oldValue[4]				#print read2Seq				newValue = [numSpaces, readID, readSequence, read2ID, read2Seq]				del reads[readKey]				reads[readKey] = newValue			elif readPair == 2:				oldValue = reads[readKey]				read1ID = oldValue[1]				read1Seq = oldValue[2]				newValue = [numSpaces, read1ID, read1Seq, readID, readSequence]				del reads[readKey]				reads[readKey] = newValue			else:				print "Error #2"				print "\t\t" + readID + "\t" + readPair			#del reads[readKey]			#reads[readKey] = newValue	#print readsallKeys = reads.keys()preJoinedReads = [] ###To handle the sequences without _1 or _2bothReads = []onlyRead1 = []onlyRead2 = []for element in allKeys:	values = reads[element]	if values[3] == "PreJoined":		preJoinedReads.append(element)	else:		if type(values[1]) == str:			read1 = True		else:			read1 = False		if type(values[3]) == str:			read2 = True		else:			read2 = False		if read1 == True and read2 == True:			bothReads.append(element)		elif read1 == True and read2 == False:			onlyRead1.append(element)		elif read1 == False and read2 == True:			onlyRead2.append(element)		else:			print "Error #3 \t \t" + elementnumPreJoinedReads = len(preJoinedReads)numBothReads = len(bothReads)numOnlyRead1 = len(onlyRead1)numOnlyRead2 = len(onlyRead2)###Whole datasetlogFile.write("The following of the original data are the number of reads with 2 pairs, or only one pair: \n")logFile.write("Pre-Joind BOTH READS: len - " + str(numPreJoinedReads) + "\n") #+ "\t" + str(bothReads)logFile.write("BOTH READS: len - " + str(numBothReads) + "\n") #+ "\t" + str(bothReads)logFile.write("ONLY READ 1: len - " + str(numOnlyRead1) + "\n") #+ "\t" + str(onlyRead1)logFile.write("ONLY READ 2: len - " + str(numOnlyRead2) + "\n") #+ "\t" + str(onlyRead2)logFile.write("\n\n")#######Create a definition for instilling length criteria#########def lengthCriteria(sequence):	sequenceNoGaps = sequence.replace("-","")	sequenceLen = len(sequenceNoGaps)	#####Can alter length criteria here######	if sequenceLen >= minLength:		return True	else:		return FalselongPreJoinedReads = 0longRead1 = 0longRead2 = 0longBothReads = 0for element in preJoinedReads:	data = reads[element]	seqName = data[1]	spaces= data[0]	alnSeq = data[2]	numSpaces = " "*spaces	newLine = "\n"	outputToFile = seqName + numSpaces + alnSeq + newLine	if lengthCriteria(alnSeq) == True:		#print outputToFile		outputFile.write(outputToFile)		longPreJoinedReads+=1for element in onlyRead1:	data = reads[element]	seqName = data[1]	spaces = data[0]	alnSeq = data[2]	numSpaces = " "*spaces	newLine = "\n"	outputToFile = seqName + numSpaces + alnSeq + newLine	if lengthCriteria(alnSeq) == True:		#print outputToFile		outputFile.write(outputToFile)		longRead1+=1	#else:		#print "SEQUENCE " + seqName + " is too short!"for element in onlyRead2:	data = reads[element]	seqName = data[3]	spaces = data[0]	alnSeq = data[4]	numSpaces = " "*spaces	newLine = "\n" 	outputToFile = seqName + numSpaces + alnSeq + newLine	if lengthCriteria(alnSeq) == True:		#print outputToFile		outputFile.write(outputToFile)		longRead2+=1	#else:		#print "SEQUENCE " + seqName + " is too short!"for element in bothReads:	data = reads[element]	seqName = element + "0"	spaces = data[0]	numSpaces = " "*spaces	read1 = data[2]	read2 = data[4]	lenSeq = len(read1)	index = 0	joinedRead = []	while lenSeq > index:		positionRead1 = read1[index]		positionRead2 = read2[index]		if positionRead1 == positionRead2:			joinedRead.append(positionRead1)		elif positionRead1 != positionRead2:			if positionRead1 != "-":				joinedRead.append(positionRead1)			else:				joinedRead.append(positionRead2)		index += 1	stringRead = ''.join(joinedRead)	outputToFile = seqName + numSpaces + stringRead + newLine	if lengthCriteria(stringRead) == True:		#print outputToFile		outputFile.write(outputToFile)		longBothReads+=1	#else:	#	print "SEQUENCE " + seqName + " is too short!"logFile.write("*****************************************************************************************\n")logFile.write("The following are the set of reads in the output file that are longer than __" + str(minLength) + "__ \n")#print "Reads longer than " + str(minLength)logFile.write("LONG Pre-Joined BOTH READS: len - " + str(longPreJoinedReads) + "\n") #+ "\t" + str(preJoinedBothReads)logFile.write("LONG BOTH READS: len - " + str(longBothReads) + "\n") #+ "\t" + str(bothReads)logFile.write("LONG ONLY READ 1: len - " + str(longRead1) + "\n") #+ "\t" + str(onlyRead1)logFile.write("LONG ONLY READ 2: len - " + str(longRead2) + "\n") #+ "\t" + str(onlyRead2)numAllReads = numBothReads*2 + numOnlyRead1 + numOnlyRead2 + numPreJoinedReads*2numLongReads = longBothReads*2 + longRead1 + longRead2 + longPreJoinedReads*2percentTotal = '%.2f' % ((float(numLongReads) / numAllReads)*100)logFile.write("\nPerecent of reads from total dataset that are longer than " + str(minLength) + ": " + str(percentTotal) + "%\n")percentPairedEndReads = '%.2f' % (((float(longBothReads*2) + float(longPreJoinedReads*2)) / (longBothReads*2 + longRead1 + longRead2 + longPreJoinedReads*2))*100)percentPairedEndReads = str(percentPairedEndReads)logFile.write("\nPercent of long reads with pairs: " + percentPairedEndReads + "%\n")logFile.write("\n\n")logFile.write("*****************************************************************************************\n")logFile.write("Reads that are written to output file \n")logFile.write("\nReads with mate pairs joined: \n")logFile.write(", ".join(bothReads))logFile.write("\n\nReads with only Read 1: \n")logFile.write(", ".join(onlyRead1))logFile.write("\n\nReads with only Read 2: \n")logFile.write(", ".join(onlyRead2))logFile.write("\n\nReads that were already pre-Joined: \n")logFile.write(", ".join(preJoinedReads))###To write header in new alignment file:numberReadsToPlace = longBothReads + longRead1 + longRead2 + longPreJoinedReadstotalSequencesInFile = numberReadsToPlace + refCountoutputFile.close()###Depending on size of file and amount of memory available, this may not work -- in which case you would need to read line by linetempFile = open(outputFileName, "r")tempRead = tempFile.read()tempFile.close()finalFile = open(outputFileName, "w")finalFile.write(str(totalSequencesInFile) + " " + numPositionsInAln) ##not 100% sure about whether the space is required before newlinefinalFile.write(tempRead)finalFile.close()